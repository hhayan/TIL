###JOIN, UNION, 서브쿼리
-INNER JOIN, LEFT JOIN 차이: customer, sales 테이블에서 주문한 고객들만 정보: INNER JOIN
-LEFT JOIN 에서 NULL값 떄문에 COUNT 주의 count(*): null값 포함 / count(id): id만 카운트
--COALESCE(널값, 0)
--DATEDIFF

파일명: P09
-- 문제 6: 고객별 주문 통계 (INNER JOIN) [고객명, 유형, 주문횟수, 총구매, 평균구매, 최근주문일]
-- 문제 9: case문 앞에 컬럼수식 가능한지? 가능
-- 문제 10

-서브쿼리 오류 해결
1. 쉼표 추가:
첫 번째 CASE 문(총매출등급)과 두 번째 CASE 문(주문등급) 사이에 쉼표(,)를 추가하여 구문을 올바르게 분리했습니다.
2. 쿼리 안에 쉼표 누락

- 인라인뷰 안에 테이블이 먼저 생성되므로, 외부에서 as 영업사원 사용가능! 
파일명: 20-subquery
SELECT 영업사원
from절(sales_rep AS 영업사원)
-인라인뷰: 필요한 컬럼 생성 가넝~
-인라인뷰는 테이블이니까 내부에서 join도 가능, 외부에서 join도 가능

*case문에 함수 사용할 경우 외부쿼리에서 grouping된 case에 못들어감
pgadmin4
-인덱스란?
결론적으로, 복합 인덱스는 데이터베이스에서 여러 가지 조건을 동시에 사용하여 정보를 빠르고 효율적으로 찾을 수 있도록 도와주는 아주 중요한 도구라고 할 수 있어요!

복합 인덱스에서 컬럼의 순서는 매우 중요하며, 인덱스 성능에 큰 영향을 미칩니다.
일반적으로 자주 사용되는 컬럼을 앞에,  선택도(데이터 중복도)가 높은 컬럼을 앞에 위치시키는 것이 좋습니다.
또한, WHERE 절에서 사용되는 순서대로 인덱스를 구성하는 것이 효율적입니다.
선택도:
선택도란 특정 컬럼의 고유한 값의 수를 의미하며, 선택도가 높을수록(%) 데이터 검색 시 필터링 효과가 커서 인덱스 성능 향상에 유리합니다.
WHERE 절 사용 순서:
복합 인덱스는 구성된 컬럼 순서대로 정렬되기 때문에, WHERE 절에서 인덱스 컬럼을 사용할 때 앞쪽에 위치한 컬럼부터 순서대로 사용해야 인덱스 효율이 높아집니다.
ORDER BY 절 사용:
ORDER BY 절에서 복합 인덱스 컬럼을 사용하는 경우에도, WHERE 절과 마찬가지로 앞쪽 컬럼부터 순서대로 사용해야 인덱스 효과를 볼 수 있습니다.
카디널리티(데이터 집합의 Unique 개수):
카디널리티가 높은 컬럼을 앞에 배치하면 인덱스 스캔 범위를 줄여 성능을 향상시킬 수 있습니다.
UPDATE 빈도:
인덱스 컬럼으로 자주 변경되는 컬럼을 선택하면 인덱스 업데이트 비용이 증가하여 성능 저하를 유발할 수 있습니다.
예시: 예를 들어, users 테이블에 country, city, name 컬럼으로 구성된 복합 인덱스를 생성한다고 가정해 봅시다.
만약 주로 country와 city를 기준으로 검색하는 경우가 많다면, (country, city, name) 순서로 인덱스를 생성하는 것이 좋습니다.
주의사항:
복합 인덱스는 무분별하게 많이 생성하는 것보다, 실제 사용 빈도와 성능 요구사항을 고려하여 필요한 컬럼 위주로 구성하는 것이 좋습니다.
복합 인덱스를 생성할 때는 데이터베이스 시스템의 특성과 인덱스 구조를 이해하고 최적의 순서를 결정해야 합니다.

group by절 - select절 함수

CREATE VIEW customer_summary AS <- 뷰테이블 임시저장 기능

어려운 문제: 고객 간 구매 패턴 유사성

사용하는 경우, 차이점:
ANY(조건 하나라도, OR),
ALL(전부),
IN,
EXIST, NOT EXIST(존재하냐, 존재하지 않느냐)

클린코드: 시간, 공간을 덜 쓰고 데이터를 사용하는 코드